---
title: "Apollo Clientのキャッシュから考えるGraphQL Server設計"
emoji: "📊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["GraphQL","Apollo","cache","backend"]
published: false
---

# 自己紹介

業務では主にGraphQL Serverの開発を担当しています。

# はじめに
&emsp;GraphQLのClientには、以下のように設定を有効にするだけで効率よくキャッシュしてくれる仕組みが備わっています。

```js:index.ts
import { InMemoryCache, ApolloClient } from '@apollo/client';

const client = new ApolloClient({
  cache: new InMemoryCache(options)
});
```

しかし、キャッシュの性能を発揮するにはスキーマ・サーバー設計を適切に行わなければなりません。
つまり、サーバーサイドエンジニアにとってもキャッシュの仕組みの理解は重要です。
&emsp;本記事では、GraphQL Server構築において考慮すべき点をまとめました。
※ Clientライブラリは、Apollo ClientやRelayなどが存在が、Apollo Clientについての内容になります。

# GraphQLとは

&emsp;GraphQLはAPIのためのクエリ言語であり、そのクエリを実行するためのランタイムです。
Client側が必要とする情報のみをクエリ言語でリクエストし、取得することができます。
これにより、レスポンスのデータ量をコントロールし、削減できます。

# キャッシュの仕組み
&emsp;サーバーから受け取ったレスポンスは、インメモリキャッシュに保存されます。
例えば、Userを取得する場合は、以下のような流れになります。
- 初回
  1. Clientはid：5のUserをリクエストします。
  2. キャッシュにid：5のUserが存在するか確認します。
  3. 初回はキャッシュに存在しないため、サーバーへUserの取得を問い合わせます。
  4. サーバーから取得したUserはキャッシュされます。
  5. UserをClientに返却します。
- ２回目以降
  1. Clientはid：5のUserをリクエストします。
  2. キャッシュにid：5のUserが存在するか確認します。
  3. サーバへは問い合わせずに、ClientにUserを返却します。
![いい感じに図を入れる]()

# キャッシュの正規化
GraphQLのクエリはネストされたオブジェクトをまとめて取得できます。
実際のプロジェクトでは、このような複雑なクエリを扱うことの方が多いでしょう。
```json:重複したキャッシュ
{
  "ROOT_QUERY":{
    "getUserAll":[
      {
        "id": 1,
        "name": "ユーザー1",
        "item": [
          {"id": 1,"name": "アイテム1","_typename": "Item"},
          {"id": 2,"name": "アイテム2","_typename": "Item"}
        ],
        "__typename": "User"
      },
      {
        "id":2,
        "name":"ユーザー2",
        "item":[
          {"id":1,"name":"アイテム1","price":1000,"_typename":"Item"}
        ],
        "__typename":"User"
      }
    ]
  }
}
```

巨大なクエリの問い合わせ結果はメモリの圧迫につながりますし、何もいいことはありません。
Apollo Clientにはオブジェクトを最小単位に分割し、保存する機能が備わっています。
分割したオブジェクト同士の関連付けは、「__typename:id」をキーとして行われます。
また、フィールドに差分がある同一キーのオブジェクトを取得した場合は、ひとつのオブジェクトにマージされ重複は最小限に抑えられます。
```json:正規化されたキャッシュ
{
  "User:1": {
    "id": 1,
    "name": "ユーザー1",
    "__typename": "User",
    "item":[
      {"__ref":"Item:1"},
      {"__ref":"Item:2"}
    ]
  },
  "User:2": {
    "id":2,
    "name":"ユーザー2",
    "__typename":"User",
    "item":[
      {"__ref":"Item:1"}
    ]
  },
  "Item:1":{"id":1,"name":"アイテム1","price":1000,"_typename":"Item"},
  "Item:2":{"id":2,"name":"アイテム2","_typename":"Item"},
  "ROOT_QUERY": {
    "getUserAll": [
      {"__ref":"User:1"},
      {"__ref":"User:2"}
    ]
  }
}
```

上記のように、「__typename:id」をキーとして正規化されます。
GraphQL Serverは各オブジェクトが__typenameとidを返却できるように実装しましょう。
Client側でキーを明示的に指定できますが、コミュニケーションコストや実装漏れの観点からこの方法は最後の手段にした方が良いと思います。

# Get

# Create

# Update

# DELETE

# 参考
[Demystifying Cache Normalization](https://www.apollographql.com/blog/apollo-client/caching/demystifying-cache-normalization/)
[Caching in Apollo Client](https://www.apollographql.com/docs/react/caching/overview/)