---
title: "Apollo Clientのキャッシュから考えるスキーマ設計"
emoji: "📊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["GraphQL","Apollo","cache","backend"]
published: false
---

# 自己紹介

業務では主にGraphQL Serverの開発を担当しています。
Nexusを使っていてCode Firstで開発を進めている。
なので、バックエンドエンジニアが主体となってスキーマを設計することが多いです。

# はじめに
&emsp;GraphQLのClientには、以下のように設定を有効にするだけで効率よくキャッシュしてくれる仕組みが備わっています。

```js:index.ts
import { InMemoryCache, ApolloClient } from '@apollo/client';

const client = new ApolloClient({
  cache: new InMemoryCache(options)
});
```

しかし、キャッシュの性能を発揮するにはスキーマ・サーバー設計を適切に行わなければなりません。
つまり、サーバーサイドエンジニアにとってもキャッシュの仕組みの理解は重要です。
&emsp;本記事では、GraphQL Server構築において考慮すべき点をまとめました。
※ Clientライブラリは、Apollo ClientやRelayなどが存在が、Apollo Clientについての内容になります。

# GraphQLとは

&emsp;GraphQLはAPIのためのクエリ言語であり、そのクエリを実行するためのランタイムです。
Client側が必要とする情報のみをクエリ言語でリクエストし、取得することができます。
これにより、レスポンスのデータ量をコントロールし、削減できます。

# キャッシュの仕組み
&emsp;サーバーから受け取ったレスポンスは、インメモリキャッシュに保存されます。
例えば、Userを取得する場合は、以下のような流れになります。
- 初回
  1. Clientはid：5のUserをリクエストします。
  2. キャッシュにid：5のUserが存在するか確認します。
  3. 初回はキャッシュに存在しないため、サーバーへUserの取得を問い合わせます。
  4. サーバーから取得したUserはキャッシュされます。
  5. UserをClientに返却します。
- ２回目以降
  1. Clientはid：5のUserをリクエストします。
  2. キャッシュにid：5のUserが存在するか確認します。
  3. サーバへは問い合わせずに、ClientにUserを返却します。
![いい感じに図を入れる]()

# キャッシュの正規化
GraphQLのクエリはネストされたオブジェクトをまとめて取得できます。
実際のプロジェクトでは、このような複雑なクエリを扱うことの方が多いでしょう。
```json:重複したキャッシュ
{
  "ROOT_QUERY":{
    "users":[
      {
        "id": 1,
        "name": "ユーザー1",
        "item": [
          {"id": 1,"name": "アイテム1","_typename": "Item"},
          {"id": 2,"name": "アイテム2","_typename": "Item"}
        ],
        "__typename": "User"
      },
      {
        "id":2,
        "name":"ユーザー2",
        "item":[
          {"id":1,"name":"アイテム1","price":1000,"_typename":"Item"}
        ],
        "__typename":"User"
      }
    ]
  }
}
```

巨大なクエリの問い合わせ結果はメモリの圧迫につながりますし、何もいいことはありません。
Apollo Clientにはオブジェクトを最小単位に分割し、保存する機能が備わっています。
分割したオブジェクト同士の関連付けは、「__typename:id」をキーとして行われます。
また、フィールドに差分がある同一キーのオブジェクトを取得した場合は、ひとつのオブジェクトにマージされ重複は最小限に抑えられます。
```json:正規化されたキャッシュ
{
  "User:1": {
    "id": 1,
    "name": "ユーザー1",
    "__typename": "User",
    "item":[
      {"__ref":"Item:1"},
      {"__ref":"Item:2"}
    ]
  },
  "User:2": {
    "id":2,
    "name":"ユーザー2",
    "__typename":"User",
    "item":[
      {"__ref":"Item:1"}
    ]
  },
  "Item:1":{"id":1,"name":"アイテム1","price":1000,"_typename":"Item"},
  "Item:2":{"id":2,"name":"アイテム2","_typename":"Item"},
  "ROOT_QUERY": {
    "users": [
      {"__ref":"User:1"},
      {"__ref":"User:2"}
    ]
  }
}
```

ROOT_QUERYに保存されているオブジェクトのキーは、`フィールド名(引数)`となります。
これによって、引数を持ったクエリや単数オブジェクトを返却する場合でも一意にキャッシュできます。
```json:正規化されたキャッシュ
{
  "ROOT_QUERY": {
    // フィールド名がキーになる
    "users": [
      {"__ref":"User:1"},
      {"__ref":"User:2"}
    ],
    // フィールド名(引数)がキーになる
    "user(id:1)":{
      {"__ref":"User:1"},
    }
  }
}
```

上記のように、「__typename:id」をキーとして正規化されます。
GraphQL Serverは各オブジェクトが__typenameとidを返却できるように実装しましょう。
Client側でキーを明示的に指定できますが、コミュニケーションコストや実装漏れの観点からこの方法は最後の手段にした方が良いと思います。

# キャッシュの更新
Mutationでデータ操作を行うと、自動的にキャッシュが更新されます。
しかし、以下の場合はキャッシュを更新できません。

- 更新したフィールドがレスポンスに含まれていない
- キャッシュされたコレクションの順序が変わる
- Mutationが追加、削除の操作を行う

### 更新したフィールドがレスポンスに含まれていない
キャッシュはレスポンスを元に各オブジェクトを更新します。
そのため、更新したフィールドをレスポンスに含めなければなりません。
１つのMutationで複数オブジェクトのフィールドを更新するケースもあるかもしれません。
その場合は、各フィールドをClientから取得できるようにオブジェクト同士の関連付けをスキーマで定義してあげましょう。

### キャッシュされたコレクションの順序が変わる
キャッシュは実はオブジェクト配列の順序を保持しています。
しかし、更新時に順序を入れ替えてしまうと、キャッシュに反映できません。
これは、ROOT_QUERYのどのキーの配列が更新されたのかを知ることができないためと考えられます。
対処方法は・・・
特にスキーマ設計で考慮する点はないと思いますが、知っておくと良いでしょう。

### Mutationが追加、削除の操作を行う
ROOT_QUERYのどのキーの配列が更新されたのかを知ることができないためと考えられます。
追加した際には、・・・・
そのため、追加したオブジェクトをレスポンス返す必要があります。
削除の場合は、・・・
削除したオブジェクトのidを返してあげましょう。

# まとめ
Apollo Clientは取得したデータをインメモリキャッシュに正規化して自動的に保存します。
以下のようにスキーマを設計することで、キャッシュ機構の性能を発揮することができます。

- オブジェクトにidと__typenameを含める
- 更新した項目を返却できるようにスキーマを定義する
  - 更新項目をオブジェクトに追加
  - オブジェクトを跨ぐ場合は、リレーションを追加
- 

<!-- メモ
nodeのキャッシュ構造確認 -->

# 参考文献
[Demystifying Cache Normalization](https://www.apollographql.com/blog/apollo-client/caching/demystifying-cache-normalization/)
[Caching in Apollo Client](https://www.apollographql.com/docs/react/caching/overview/)